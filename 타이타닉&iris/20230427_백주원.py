# -*- coding: utf-8 -*-
"""20230427 백주원.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pj32qoADMaT0s3NmiDm0mQhIZbEwJ8b6
"""

import numpy as np
import pandas as pd

import os

# Google Colab에서 Google Drive 불러오기
from google.colab import drive

# Google Drive 마운트
drive.mount('/content/drive')

# 현재 경로 확인
g = os.getcwd()
print("현재 경로:", g)

drive.mount('/content/drive')

titanic_path = '/content/drive/MyDrive/'
os.chdir(titanic_path)

current_path = os.getcwd()
print("현재 경로:", current_path)

titanic_df = pd.read_csv('titanic.csv')

# DataFrame 확인
titanic_df.head()

# 데이터프레임의 상위 5개의 데이터 확인
titanic_df.head()

titanic_df.shape

# 데이터프레임에 대한 요약 정보 확인
titanic_df.info()

titanic_df.describe()

# Age가 60세 이상인 행을 필터링하고, 'Age'와 'Name' 열만 출력
filtered_df = titanic_df[titanic_df['Age'] >= 60][['Age', 'Name']]

# 상위 3개의 행만 출력
result_df = filtered_df.head(3)

# 결과 출력
result_df

# 'Name', 'Pclass', 'Age' 열만 출력하고, Survived가 1인 행을 필터링
filtered_df = titanic_df[['Name', 'Pclass', 'Age']][titanic_df['Survived'] == 1]

# 상위 5개의 행만 출력
result_df = filtered_df.head(5)

# 결과 출력
result_df

# Age가 60세 이상, Pclass가 1등급, Sex가 female인 행을 필터링
filtered_df = titanic_df[(titanic_df['Age'] >= 60) & (titanic_df['Pclass'] == 1) & (titanic_df['Sex'] == 'female')]

# 필터링된 결과에서 'Age', 'Pclass', 'Sex' 열만 출력
result_df = filtered_df[['Age', 'Pclass', 'Sex']]

# 결과 출력
result_df

# Pclass별 여성 생존자의 수를 출력
female_survivors_by_pclass = titanic_df[titanic_df['Sex'] == 'female'].groupby('Pclass')['Survived'].sum()

# 결과 출력
female_survivors_by_pclass

# Pclass를 인덱스로 하여 각 컬럼의 개수 구하기
pclass_counts = titanic_df.groupby('Pclass').count()

# 결과 출력
pclass_counts

# 'iris.csv' 파일을 불러와서 DataFrame으로 저장
iris = pd.read_csv('iris.csv')

# DataFrame 확인
iris.head()

# 'class' 칼럼의 고유한 데이터 확인
unique_classes = iris['class'].unique()

# 결과 출력
unique_classes

# 'class' 칼럼의 고유한 데이터 개수 확인
num_unique_classes = iris['class'].nunique()

# 결과 출력
print("고유한 클래스의 개수:", num_unique_classes)

# 'class' 칼럼의 각 고유한 값들의 개수 확인
class_counts = iris['class'].value_counts()

# 결과 출력
print(class_counts)

# 꽃받침 길이 열('sepal length')의 상위 10개 데이터 확인
top_sepal_length = iris['sepal length'].head(10)

# 결과 출력
top_sepal_length

# 꽃받침의 5행부터 19행까지 슬라이싱
sepal_sliced = iris.loc[5:19, 'sepal length']

# 결과 출력
print(sepal_sliced)

# 'sepal length' 칼럼을 'petal length' 칼럼으로 나눈 결과 출력
sepal_divided_by_petal = iris['sepal length'] / iris['petal length']

# 결과 출력
print(sepal_divided_by_petal)

# 'sepal length'가 5보다 큰 데이터 추출
sepal_length_gt_5 = iris[iris['sepal length'] > 5]

# 결과 출력
sepal_length_gt_5

# 'sepal length'가 5보다 크거나, 'petal length'가 1.5보다 작은 데이터 추출
filtered_data = iris[(iris['sepal length'] > 5) | (iris['petal length'] < 1.5)]

# 결과 출력
filtered_data

# 'sepal length'가 5보다 크면서 'petal length'가 1.5보다 작은 데이터 추출
filtered_data = iris[(iris['sepal length'] > 5) & (iris['petal length'] < 1.5)]

# 결과 출력
filtered_data

# 'sepal length'가 5보다 크고 'petal length'가 1.5보다 작은 행에서 'petal width' 열 추출
filtered_petal_width = iris.loc[(iris['sepal length'] > 5) & (iris['petal length'] < 1.5), 'petal width']

# 결과 출력
filtered_petal_width

# 'class'별로 각 컬럼의 합 출력
sum_by_class = iris.groupby('class').sum()

# 결과 출력
sum_by_class

# 'class'별로 각 컬럼의 가장 큰 값과 가장 작은 값의 차이 계산
range_by_class = iris.groupby('class').agg(lambda x: x.max() - x.min())

# 결과 출력
range_by_class